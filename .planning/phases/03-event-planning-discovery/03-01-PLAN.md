---
phase: 03-event-planning-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00003_event_tables.sql
  - frontend/src/hooks/useEvents.ts
  - frontend/src/hooks/useSavedVendors.ts
autonomous: true

must_haves:
  truths:
    - "Events table exists with RLS policies for user-only access"
    - "Saved vendors table exists with RLS policies"
    - "useEvents hook provides CRUD operations for events"
    - "useSavedVendors hook provides save/unsave operations"
  artifacts:
    - path: "supabase/migrations/00003_event_tables.sql"
      provides: "events and saved_vendors tables with RLS"
      contains: "CREATE TABLE public.events"
    - path: "frontend/src/hooks/useEvents.ts"
      provides: "Event CRUD hooks"
      exports: ["useEvents", "useEvent", "useCreateEvent", "useUpdateEvent", "useDeleteEvent"]
    - path: "frontend/src/hooks/useSavedVendors.ts"
      provides: "Saved vendor hooks"
      exports: ["useSavedVendors", "useSaveVendor", "useUnsaveVendor", "useIsSaved"]
  key_links:
    - from: "frontend/src/hooks/useEvents.ts"
      to: "supabase"
      via: "supabase.from('events')"
      pattern: "supabase\\.from\\('events'\\)"
    - from: "frontend/src/hooks/useSavedVendors.ts"
      to: "supabase"
      via: "supabase.from('saved_vendors')"
      pattern: "supabase\\.from\\('saved_vendors'\\)"
---

<objective>
Create database schema and data hooks for events and saved vendors.

Purpose: Establish data layer that event wizard, discovery, and dashboard will consume
Output: Migration file with tables + RLS, two React Query hooks with full CRUD operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-event-planning-discovery/03-CONTEXT.md
@.planning/phases/03-event-planning-discovery/03-RESEARCH.md
@.planning/phases/02-vendor-supply-platform/02-02-SUMMARY.md

# Existing patterns to follow
@frontend/src/hooks/useVendorProfile.ts
@frontend/src/hooks/useProfile.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create events and saved_vendors migration</name>
  <files>supabase/migrations/00003_event_tables.sql</files>
  <action>
Create migration file with:

**events table:**
- id: UUID primary key (gen_random_uuid)
- user_id: UUID NOT NULL references profiles(id) ON DELETE CASCADE
- event_name: TEXT NOT NULL
- event_date: DATE NOT NULL
- location: TEXT (nullable - optional field per CONTEXT.md)
- guest_count: INTEGER (nullable)
- budget: INTEGER (nullable)
- categories_needed: TEXT[] DEFAULT '{}'
- categories_covered: TEXT[] DEFAULT '{}'
- created_at: TIMESTAMPTZ DEFAULT NOW()
- updated_at: TIMESTAMPTZ DEFAULT NOW()

Add updated_at trigger using existing handle_updated_at function (from 00001 migration).

**RLS policies for events:**
- SELECT: user_id = auth.uid()
- INSERT: user_id = auth.uid()
- UPDATE: user_id = auth.uid()
- DELETE: user_id = auth.uid()

**saved_vendors table:**
- id: UUID primary key
- user_id: UUID NOT NULL references profiles(id) ON DELETE CASCADE
- vendor_id: UUID NOT NULL references vendor_profiles(id) ON DELETE CASCADE
- created_at: TIMESTAMPTZ DEFAULT NOW()
- UNIQUE(user_id, vendor_id)

**RLS policies for saved_vendors:**
- SELECT: user_id = auth.uid()
- INSERT: user_id = auth.uid()
- DELETE: user_id = auth.uid()

Enable RLS on both tables.
  </action>
  <verify>
Run: `npx supabase db push` (or apply via dashboard)
Check tables exist: SELECT * FROM information_schema.tables WHERE table_name IN ('events', 'saved_vendors')
  </verify>
  <done>
Both tables created with proper columns, foreign keys, and RLS policies enabled
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useEvents hook</name>
  <files>frontend/src/hooks/useEvents.ts</files>
  <action>
Create useEvents.ts following useVendorProfile.ts pattern:

**Type definitions (inline until generated):**
```typescript
interface Event {
  id: string
  user_id: string
  event_name: string
  event_date: string // DATE stored as string
  location: string | null
  guest_count: number | null
  budget: number | null
  categories_needed: string[]
  categories_covered: string[]
  created_at: string | null
  updated_at: string | null
}

interface EventInsert {
  user_id: string
  event_name: string
  event_date: string
  location?: string | null
  guest_count?: number | null
  budget?: number | null
  categories_needed?: string[]
  categories_covered?: string[]
}

interface EventUpdate {
  id: string
  event_name?: string
  event_date?: string
  location?: string | null
  guest_count?: number | null
  budget?: number | null
  categories_needed?: string[]
  categories_covered?: string[]
}
```

**Hooks to export:**
1. `useEvents(userId)` - Fetch all events for user, staleTime 60s
2. `useEvent(eventId)` - Fetch single event by ID
3. `useCreateEvent()` - Insert mutation with query invalidation
4. `useUpdateEvent()` - Update mutation, sets updated_at to now
5. `useDeleteEvent()` - Delete mutation with query invalidation

Follow established patterns:
- Handle PGRST116 as null (no rows)
- Use queryClient.invalidateQueries on mutations
- enabled: !!userId for conditional queries
  </action>
  <verify>
TypeScript compiles without errors: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>
useEvents hook exports all 5 functions with proper types and query patterns
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useSavedVendors hook</name>
  <files>frontend/src/hooks/useSavedVendors.ts</files>
  <action>
Create useSavedVendors.ts:

**Type definitions:**
```typescript
interface SavedVendor {
  id: string
  user_id: string
  vendor_id: string
  created_at: string | null
}
```

**Hooks to export:**
1. `useSavedVendors(userId)` - Fetch all saved vendors for user
   - Join with vendor_profiles to get vendor details
   - Returns array of {saved_vendor_id, vendor: PublicVendor}
   - staleTime 30s

2. `useIsSaved(userId, vendorId)` - Check if specific vendor is saved
   - Returns boolean
   - Useful for save/unsave button state

3. `useSaveVendor()` - Insert mutation
   - Takes {user_id, vendor_id}
   - Invalidates ['saved-vendors', userId]

4. `useUnsaveVendor()` - Delete mutation
   - Takes {user_id, vendor_id}
   - Uses .eq('user_id', user_id).eq('vendor_id', vendor_id)
   - Invalidates queries

Handle unique constraint gracefully (ignore duplicate save attempts).
  </action>
  <verify>
TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>
useSavedVendors hook exports all 4 functions for save/unsave functionality
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. Migration applied successfully to Supabase
2. Both hooks compile without TypeScript errors
3. Query keys follow established patterns: ['events', userId], ['saved-vendors', userId]
4. All RLS policies use (SELECT auth.uid()) pattern for performance
</verification>

<success_criteria>
- events table exists with all columns and RLS
- saved_vendors table exists with unique constraint and RLS
- useEvents exports 5 hooks (list, single, create, update, delete)
- useSavedVendors exports 4 hooks (list, isSaved, save, unsave)
- All TypeScript types defined inline
</success_criteria>

<output>
After completion, create `.planning/phases/03-event-planning-discovery/03-01-SUMMARY.md`
</output>
