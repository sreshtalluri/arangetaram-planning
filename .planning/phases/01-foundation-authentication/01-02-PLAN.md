---
phase: 01-foundation-authentication
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - frontend/src/lib/supabase.ts
  - frontend/src/lib/auth-supabase.ts
  - frontend/package.json
autonomous: true

must_haves:
  truths:
    - "Supabase client is a singleton shared across the app"
    - "Auth functions handle email/password signup with role"
    - "Auth functions handle login with specific error messages"
    - "Auth functions handle logout"
    - "Auth functions handle password reset flow"
  artifacts:
    - path: "frontend/src/lib/supabase.ts"
      provides: "Supabase client singleton with TypeScript generics"
      exports: ["supabase"]
      min_lines: 15
    - path: "frontend/src/lib/auth-supabase.ts"
      provides: "Auth functions wrapping Supabase Auth"
      exports: ["signUp", "signIn", "signOut", "resetPassword", "updatePassword"]
      min_lines: 60
  key_links:
    - from: "frontend/src/lib/supabase.ts"
      to: "frontend/src/lib/database.types.ts"
      via: "generic import for type safety"
      pattern: "import.*Database.*from.*database.types"
    - from: "frontend/src/lib/auth-supabase.ts"
      to: "frontend/src/lib/supabase.ts"
      via: "supabase client import"
      pattern: "import.*supabase.*from.*supabase"
---

<objective>
Create Supabase client singleton and auth library functions for signup, login, logout, and password reset.

Purpose: Provide the foundational auth primitives that the AuthProvider and UI components will use. Separating the raw Supabase calls from React integration allows cleaner testing and reuse.

Output: Type-safe Supabase client and auth functions ready for integration with React context.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-authentication/01-CONTEXT.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@frontend/src/lib/database.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase client singleton</name>
  <files>frontend/src/lib/supabase.ts</files>
  <action>
Create `frontend/src/lib/supabase.ts` with:

1. Import createClient from @supabase/supabase-js
2. Import Database type from ./database.types
3. Create and export supabase client singleton:
   ```typescript
   import { createClient } from '@supabase/supabase-js'
   import type { Database } from './database.types'

   const supabaseUrl = process.env.REACT_APP_SUPABASE_URL
   const supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY

   if (!supabaseUrl || !supabaseAnonKey) {
     throw new Error('Missing Supabase environment variables')
   }

   export const supabase = createClient<Database>(
     supabaseUrl,
     supabaseAnonKey,
     {
       auth: {
         autoRefreshToken: true,
         persistSession: true,
         detectSessionInUrl: true
       }
     }
   )
   ```

Note: Use REACT_APP_ prefix (not VITE_) because existing codebase uses Create React App.
  </action>
  <verify>
- `cat frontend/src/lib/supabase.ts` shows createClient with Database generic
- No TypeScript errors: `cd frontend && npx tsc --noEmit src/lib/supabase.ts` (may need tsconfig)
  </verify>
  <done>Supabase client singleton exported with Database type for type-safe queries</done>
</task>

<task type="auto">
  <name>Task 2: Create auth library functions</name>
  <files>frontend/src/lib/auth-supabase.ts</files>
  <action>
Create `frontend/src/lib/auth-supabase.ts` with auth functions following research patterns:

```typescript
import { supabase } from './supabase'

export type UserRole = 'user' | 'vendor'

export async function signUp(
  email: string,
  password: string,
  role: UserRole,
  fullName?: string
) {
  const { data, error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      data: {
        role,
        full_name: fullName,
      },
      emailRedirectTo: `${window.location.origin}/auth/callback`,
    },
  })

  if (error) throw error
  return data
}

export async function signIn(email: string, password: string) {
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  })

  if (error) {
    // Provide specific error messages per CONTEXT.md
    if (error.message.includes('Invalid login credentials')) {
      throw new Error('Email or password is incorrect')
    }
    if (error.message.includes('Email not confirmed')) {
      throw new Error('Please verify your email before logging in')
    }
    throw error
  }

  return data
}

export async function signOut() {
  const { error } = await supabase.auth.signOut()
  if (error) throw error
}

export async function resetPassword(email: string) {
  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${window.location.origin}/auth/reset-password`,
  })
  if (error) throw error
}

export async function updatePassword(newPassword: string) {
  const { error } = await supabase.auth.updateUser({
    password: newPassword,
  })
  if (error) throw error
}

// Helper to get current session
export async function getSession() {
  const { data: { session }, error } = await supabase.auth.getSession()
  if (error) throw error
  return session
}

// Helper to get current user
export async function getCurrentUser() {
  const { data: { user }, error } = await supabase.auth.getUser()
  if (error) throw error
  return user
}
```

Key points:
- signUp passes role in user_metadata (trigger copies to profiles table)
- signIn returns specific error messages per CONTEXT.md decisions
- Password reset uses 1-hour expiry (Supabase default)
- emailRedirectTo handles email verification callback
  </action>
  <verify>
- `cat frontend/src/lib/auth-supabase.ts` shows all 7 exported functions
- `grep "export async function" frontend/src/lib/auth-supabase.ts | wc -l` returns 7
  </verify>
  <done>Auth library provides signUp, signIn, signOut, resetPassword, updatePassword, getSession, getCurrentUser</done>
</task>

<task type="auto">
  <name>Task 3: Add TypeScript support to frontend</name>
  <files>
    - frontend/tsconfig.json
    - frontend/package.json
  </files>
  <action>
1. Install TypeScript and React types:
   `cd frontend && yarn add -D typescript @types/react @types/react-dom`

2. Create frontend/tsconfig.json:
   ```json
   {
     "compilerOptions": {
       "target": "ES2020",
       "lib": ["ES2020", "DOM", "DOM.Iterable"],
       "module": "ESNext",
       "moduleResolution": "bundler",
       "jsx": "react-jsx",
       "strict": true,
       "noEmit": true,
       "esModuleInterop": true,
       "skipLibCheck": true,
       "forceConsistentCasingInFileNames": true,
       "resolveJsonModule": true,
       "isolatedModules": true,
       "baseUrl": "src",
       "paths": {
         "@/*": ["./*"]
       }
     },
     "include": ["src/**/*.ts", "src/**/*.tsx"],
     "exclude": ["node_modules"]
   }
   ```

3. Add type-check script to package.json:
   ```json
   "scripts": {
     "type-check": "tsc --noEmit"
   }
   ```

Note: The existing .js/.jsx files will continue to work. New TypeScript files (.ts/.tsx) are opt-in. CRA with Craco supports TypeScript out of the box.
  </action>
  <verify>
- `cat frontend/tsconfig.json` shows valid TypeScript config
- `cd frontend && yarn type-check` completes (may have errors in existing JS files, that's expected)
- New .ts files in lib/ are recognized
  </verify>
  <done>TypeScript configured for frontend, new auth files type-check successfully</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `frontend/src/lib/supabase.ts` exports typed supabase client
2. `frontend/src/lib/auth-supabase.ts` exports all auth functions
3. `yarn --cwd frontend type-check` runs (warnings OK, errors on new files not OK)
4. Files use correct env var prefix (REACT_APP_)
</verification>

<success_criteria>
- Supabase client singleton created with Database generic type
- Auth functions wrap Supabase Auth with proper error handling
- TypeScript is configured and new files type-check
- All functions match patterns from research document
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-02-SUMMARY.md`
</output>
