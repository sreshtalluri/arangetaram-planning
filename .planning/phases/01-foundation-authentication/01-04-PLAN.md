---
phase: 01-foundation-authentication
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - frontend/src/contexts/AuthContext.tsx
  - frontend/src/hooks/useAuth.ts
  - frontend/src/components/ProtectedRoute.tsx
  - frontend/src/index.js
autonomous: true

must_haves:
  truths:
    - "Auth state persists across browser refresh"
    - "Auth state updates reactively on login/logout"
    - "User role is accessible from auth context"
    - "Protected routes redirect unauthenticated users to login"
    - "Existing auth.js is replaced, not modified alongside"
  artifacts:
    - path: "frontend/src/contexts/AuthContext.tsx"
      provides: "Auth context with Supabase onAuthStateChange"
      exports: ["AuthProvider", "useAuthContext"]
      min_lines: 60
    - path: "frontend/src/hooks/useAuth.ts"
      provides: "Convenience hook combining auth state with profile"
      exports: ["useAuth"]
      min_lines: 30
    - path: "frontend/src/components/ProtectedRoute.tsx"
      provides: "Route wrapper that redirects unauthenticated users"
      exports: ["ProtectedRoute"]
      min_lines: 20
  key_links:
    - from: "frontend/src/contexts/AuthContext.tsx"
      to: "frontend/src/lib/supabase.ts"
      via: "onAuthStateChange subscription"
      pattern: "supabase.auth.onAuthStateChange"
    - from: "frontend/src/hooks/useAuth.ts"
      to: "frontend/src/hooks/useProfile.ts"
      via: "profile fetch for role access"
      pattern: "useProfile"
    - from: "frontend/src/components/ProtectedRoute.tsx"
      to: "frontend/src/contexts/AuthContext.tsx"
      via: "auth state check"
      pattern: "useAuthContext"
---

<objective>
Create React auth context with Supabase integration, useAuth hook, and ProtectedRoute component.

Purpose: Replace the existing auth.js with Supabase-powered authentication that persists across refresh and updates reactively. ProtectedRoute enables guarding pages that require authentication.

Output: Complete auth state management integrated with Supabase, ready for UI pages to use.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-authentication/01-CONTEXT.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@frontend/src/lib/auth.js
@frontend/src/lib/supabase.ts
@frontend/src/lib/auth-supabase.ts
@frontend/src/hooks/useProfile.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuthContext with Supabase integration</name>
  <files>frontend/src/contexts/AuthContext.tsx</files>
  <action>
Create `frontend/src/contexts/AuthContext.tsx`:

```typescript
import { createContext, useContext, useEffect, useState, ReactNode } from 'react'
import { Session, User } from '@supabase/supabase-js'
import { supabase } from '../lib/supabase'
import { signUp as authSignUp, signIn as authSignIn, signOut as authSignOut, UserRole } from '../lib/auth-supabase'

interface AuthContextType {
  session: Session | null
  user: User | null
  loading: boolean
  signUp: (email: string, password: string, role: UserRole, fullName?: string) => Promise<void>
  signIn: (email: string, password: string) => Promise<void>
  signOut: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: ReactNode }) {
  const [session, setSession] = useState<Session | null>(null)
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session)
      setUser(session?.user ?? null)
      setLoading(false)
    })

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setSession(session)
        setUser(session?.user ?? null)
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  const signUp = async (email: string, password: string, role: UserRole, fullName?: string) => {
    await authSignUp(email, password, role, fullName)
    // Session will be set by onAuthStateChange after email verification
  }

  const signIn = async (email: string, password: string) => {
    const { session } = await authSignIn(email, password)
    // onAuthStateChange will handle state update, but we can set immediately for faster UI
    setSession(session)
    setUser(session?.user ?? null)
  }

  const signOut = async () => {
    await authSignOut()
    // onAuthStateChange will handle state update
  }

  const value: AuthContextType = {
    session,
    user,
    loading,
    signUp,
    signIn,
    signOut,
  }

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuthContext() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuthContext must be used within an AuthProvider')
  }
  return context
}
```

Key points per research Pattern 2:
- getSession() for initial load
- onAuthStateChange for reactive updates
- Cleanup subscription on unmount
- Loading state for initial session check
  </action>
  <verify>
- `cat frontend/src/contexts/AuthContext.tsx` shows AuthProvider and useAuthContext exports
- `grep "onAuthStateChange" frontend/src/contexts/AuthContext.tsx` finds the subscription
  </verify>
  <done>AuthContext provides session, user, loading state, and auth methods via Supabase</done>
</task>

<task type="auto">
  <name>Task 2: Create useAuth hook combining auth and profile</name>
  <files>frontend/src/hooks/useAuth.ts</files>
  <action>
Create `frontend/src/hooks/useAuth.ts` that combines auth context with profile data:

```typescript
import { useAuthContext } from '../contexts/AuthContext'
import { useProfile } from './useProfile'

export function useAuth() {
  const { session, user, loading: authLoading, signUp, signIn, signOut } = useAuthContext()
  const { data: profile, isLoading: profileLoading, error: profileError } = useProfile(user?.id)

  // Derive role from profile (database source of truth) or user metadata (fallback)
  const role = profile?.role ?? (user?.user_metadata?.role as 'user' | 'vendor' | undefined)

  // Convenience checks
  const isAuthenticated = !!session
  const isGuest = !session
  const isVendor = role === 'vendor'
  const isUser = role === 'user'

  return {
    // Session & User
    session,
    user,
    profile,

    // Loading states
    loading: authLoading || (isAuthenticated && profileLoading),

    // Role & Auth status
    role,
    isAuthenticated,
    isGuest,
    isVendor,
    isUser,

    // Auth actions
    signUp,
    signIn,
    signOut,

    // Profile error (for debugging)
    profileError,
  }
}

// Re-export for convenience
export type { UserRole } from '../lib/auth-supabase'
```

This hook:
- Combines AuthContext state with useProfile data
- Provides role from profile table (DB is source of truth)
- Includes convenience booleans for common checks
- Handles loading state correctly (auth + profile)
  </action>
  <verify>
- `cat frontend/src/hooks/useAuth.ts` shows combined auth and profile logic
- `grep "isVendor\|isUser\|isGuest" frontend/src/hooks/useAuth.ts` finds convenience checks
  </verify>
  <done>useAuth hook provides unified auth state with profile and role convenience methods</done>
</task>

<task type="auto">
  <name>Task 3: Create ProtectedRoute component and update index.js</name>
  <files>
    - frontend/src/components/ProtectedRoute.tsx
    - frontend/src/index.js
  </files>
  <action>
1. Create `frontend/src/components/ProtectedRoute.tsx`:

```typescript
import { Navigate, useLocation } from 'react-router-dom'
import { useAuth } from '../hooks/useAuth'

interface ProtectedRouteProps {
  children: React.ReactNode
  requiredRole?: 'user' | 'vendor'
}

export function ProtectedRoute({ children, requiredRole }: ProtectedRouteProps) {
  const { isAuthenticated, isVendor, isUser, loading } = useAuth()
  const location = useLocation()

  // Show nothing while checking auth state
  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    )
  }

  // Redirect to login if not authenticated
  if (!isAuthenticated) {
    // Save intended destination for redirect after login
    return <Navigate to="/login" state={{ from: location }} replace />
  }

  // Check role if required
  if (requiredRole === 'vendor' && !isVendor) {
    return <Navigate to="/" replace />
  }
  if (requiredRole === 'user' && !isUser) {
    return <Navigate to="/" replace />
  }

  return <>{children}</>
}
```

2. Update `frontend/src/index.js` to use new AuthProvider:

Replace the import:
```javascript
// Remove: import { AuthProvider } from './lib/auth'
import { AuthProvider } from './contexts/AuthContext'
```

Keep QueryClientProvider wrapper from Plan 03. Final structure:
```javascript
<QueryClientProvider client={queryClient}>
  <AuthProvider>
    <App />
  </AuthProvider>
</QueryClientProvider>
```

3. Rename old auth.js to auth.js.bak to preserve for reference during migration:
   `mv frontend/src/lib/auth.js frontend/src/lib/auth.js.bak`

This allows gradual migration of components from old auth to new useAuth hook.
  </action>
  <verify>
- `cat frontend/src/components/ProtectedRoute.tsx` shows Navigate redirect logic
- `grep "AuthContext" frontend/src/index.js` finds new import
- `ls frontend/src/lib/auth.js.bak` confirms old file preserved
  </verify>
  <done>ProtectedRoute guards routes, index.js uses new AuthProvider, old auth preserved for reference</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. AuthContext.tsx exports AuthProvider and useAuthContext
2. useAuth hook combines auth state with profile
3. ProtectedRoute component handles authentication checks
4. index.js imports from contexts/AuthContext, not lib/auth
5. Old auth.js preserved as .bak for migration reference
</verification>

<success_criteria>
- Auth state persists across browser refresh (via Supabase persistSession)
- Auth state updates reactively on login/logout (via onAuthStateChange)
- Role accessible via useAuth().role or useAuth().isVendor/isUser
- ProtectedRoute redirects to /login with return URL in state
- App compiles without errors (may have runtime issues until pages updated)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-04-SUMMARY.md`
</output>
