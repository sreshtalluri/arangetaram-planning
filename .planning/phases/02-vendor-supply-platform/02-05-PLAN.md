---
phase: 02-vendor-supply-platform
plan: 05
type: execute
wave: 2
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - frontend/src/components/vendor/PortfolioUploader.tsx
  - frontend/src/components/vendor/PortfolioGallery.tsx
  - frontend/src/components/vendor/AvailabilityCalendar.tsx
autonomous: true

must_haves:
  truths:
    - "Vendor can upload portfolio images with preview"
    - "Vendor can drag-to-reorder portfolio images"
    - "Vendor can delete portfolio images"
    - "Vendor can select dates to mark as unavailable"
    - "Blocked dates show as 'Booked' with visual distinction"
  artifacts:
    - path: "frontend/src/components/vendor/PortfolioUploader.tsx"
      provides: "Image upload with preview and validation"
      min_lines: 60
    - path: "frontend/src/components/vendor/PortfolioGallery.tsx"
      provides: "Sortable image grid with dnd-kit"
      min_lines: 100
    - path: "frontend/src/components/vendor/AvailabilityCalendar.tsx"
      provides: "Calendar with multiple date selection"
      min_lines: 80
  key_links:
    - from: "PortfolioUploader.tsx"
      to: "storage.ts"
      via: "uploadPortfolioImage function"
      pattern: "uploadPortfolioImage"
    - from: "PortfolioGallery.tsx"
      to: "@dnd-kit/sortable"
      via: "SortableContext and useSortable"
      pattern: "useSortable"
    - from: "AvailabilityCalendar.tsx"
      to: "useBlockedDates"
      via: "hook for blocked date data"
      pattern: "useBlockedDates"
---

<objective>
Create portfolio management components (uploader with preview, sortable gallery) and availability calendar with multiple date selection.

Purpose: Provides the visual media and scheduling capabilities vendors need to showcase their work and manage bookings.
Output: Three components ready for integration into vendor dashboard.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-vendor-supply-platform/02-CONTEXT.md
@.planning/phases/02-vendor-supply-platform/02-RESEARCH.md

@frontend/src/lib/storage.ts
@frontend/src/hooks/usePortfolio.ts
@frontend/src/hooks/useAvailability.ts
@frontend/src/components/ui/calendar.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create portfolio uploader component</name>
  <files>frontend/src/components/vendor/PortfolioUploader.tsx</files>
  <action>
Create PortfolioUploader.tsx with image preview before upload:

```typescript
import { useState, useRef, useEffect } from 'react'
import { toast } from 'sonner'
import { Button } from '@/components/ui/button'
import { uploadPortfolioImage, MAX_FILE_SIZE, ALLOWED_TYPES, StorageError } from '@/lib/storage'
import { useAddPortfolioImage } from '@/hooks/usePortfolio'
import { Upload, X, Loader2, ImagePlus } from 'lucide-react'

interface PortfolioUploaderProps {
  vendorId: string
  currentCount: number
  maxImages?: number
  onUploadComplete?: () => void
}

export function PortfolioUploader({
  vendorId,
  currentCount,
  maxImages = 10,
  onUploadComplete
}: PortfolioUploaderProps) {
  const [preview, setPreview] = useState<string | null>(null)
  const [file, setFile] = useState<File | null>(null)
  const [uploading, setUploading] = useState(false)
  const inputRef = useRef<HTMLInputElement>(null)
  const addImage = useAddPortfolioImage()

  const canUpload = currentCount < maxImages

  // Cleanup preview URL on unmount
  useEffect(() => {
    return () => {
      if (preview) URL.revokeObjectURL(preview)
    }
  }, [preview])

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const selected = e.target.files?.[0]
    if (!selected) return

    // Validate file type
    if (!ALLOWED_TYPES.includes(selected.type)) {
      toast.error('Please select a JPEG, PNG, or WebP image')
      return
    }

    // Validate file size
    if (selected.size > MAX_FILE_SIZE) {
      toast.error('Image must be under 5MB')
      return
    }

    // Create preview
    const objectUrl = URL.createObjectURL(selected)
    if (preview) URL.revokeObjectURL(preview)
    setPreview(objectUrl)
    setFile(selected)
  }

  const handleCancel = () => {
    if (preview) URL.revokeObjectURL(preview)
    setPreview(null)
    setFile(null)
    if (inputRef.current) inputRef.current.value = ''
  }

  const handleUpload = async () => {
    if (!file || !vendorId) return

    setUploading(true)
    try {
      const orderIndex = currentCount // Next available index
      const result = await uploadPortfolioImage(vendorId, file, orderIndex)

      await addImage.mutateAsync({
        vendor_id: vendorId,
        storage_path: result.path,
        order_index: orderIndex,
      })

      toast.success('Image uploaded!')
      handleCancel()
      onUploadComplete?.()
    } catch (error) {
      if (error instanceof StorageError) {
        toast.error(error.message)
      } else {
        toast.error('Failed to upload image')
      }
    } finally {
      setUploading(false)
    }
  }

  if (!canUpload) {
    return (
      <div className="border-2 border-dashed border-gray-200 rounded-lg p-8 text-center">
        <p className="text-gray-500">Maximum {maxImages} images reached</p>
      </div>
    )
  }

  return (
    <div className="border-2 border-dashed border-gray-300 rounded-lg p-6">
      {preview ? (
        <div className="space-y-4">
          <div className="relative inline-block">
            <img
              src={preview}
              alt="Preview"
              className="max-w-xs max-h-48 rounded-lg object-cover"
            />
            <button
              onClick={handleCancel}
              className="absolute -top-2 -right-2 w-6 h-6 bg-red-500 text-white rounded-full flex items-center justify-center hover:bg-red-600"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
          <div className="flex gap-2">
            <Button onClick={handleUpload} disabled={uploading}>
              {uploading ? (
                <>
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                  Uploading...
                </>
              ) : (
                <>
                  <Upload className="w-4 h-4 mr-2" />
                  Upload
                </>
              )}
            </Button>
            <Button variant="outline" onClick={handleCancel} disabled={uploading}>
              Cancel
            </Button>
          </div>
        </div>
      ) : (
        <label className="flex flex-col items-center cursor-pointer">
          <ImagePlus className="w-12 h-12 text-gray-400 mb-2" />
          <span className="text-sm font-medium text-gray-600">
            Click to select an image
          </span>
          <span className="text-xs text-gray-400 mt-1">
            JPEG, PNG, or WebP up to 5MB ({currentCount}/{maxImages})
          </span>
          <input
            ref={inputRef}
            type="file"
            accept="image/jpeg,image/png,image/webp"
            onChange={handleFileSelect}
            className="hidden"
          />
        </label>
      )}
    </div>
  )
}
```
  </action>
  <verify>
- File exists at frontend/src/components/vendor/PortfolioUploader.tsx
- Uses uploadPortfolioImage from storage.ts
- Shows preview using URL.createObjectURL
- Validates file size (MAX_FILE_SIZE) and type (ALLOWED_TYPES)
- Shows current/max count
  </verify>
  <done>
Portfolio uploader with preview, validation, and upload capability ready.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sortable portfolio gallery</name>
  <files>frontend/src/components/vendor/PortfolioGallery.tsx</files>
  <action>
Create PortfolioGallery.tsx with dnd-kit drag-to-reorder:

```typescript
import { useState } from 'react'
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core'
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  useSortable,
  rectSortingStrategy,
} from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'
import { toast } from 'sonner'
import { Button } from '@/components/ui/button'
import { usePortfolio, useReorderPortfolio, useDeletePortfolioImage, type PortfolioImage } from '@/hooks/usePortfolio'
import { deletePortfolioImage as deleteFromStorage, getPublicUrl } from '@/lib/storage'
import { GripVertical, Trash2, Loader2 } from 'lucide-react'

interface SortableImageProps {
  image: PortfolioImage
  onDelete: (id: string) => void
  isDeleting: boolean
}

function SortableImage({ image, onDelete, isDeleting }: SortableImageProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: image.id })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  }

  const imageUrl = getPublicUrl(image.storage_path)

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="relative group bg-white rounded-lg overflow-hidden shadow-sm border"
    >
      <img
        src={imageUrl}
        alt={image.caption || 'Portfolio image'}
        className="w-full h-48 object-cover"
      />

      {/* Drag handle */}
      <button
        {...attributes}
        {...listeners}
        className="absolute top-2 left-2 p-1.5 bg-white/90 rounded shadow opacity-0 group-hover:opacity-100 transition-opacity cursor-grab active:cursor-grabbing"
      >
        <GripVertical className="w-4 h-4 text-gray-600" />
      </button>

      {/* Delete button */}
      <button
        onClick={() => onDelete(image.id)}
        disabled={isDeleting}
        className="absolute top-2 right-2 p-1.5 bg-red-500 text-white rounded shadow opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-600 disabled:opacity-50"
      >
        {isDeleting ? (
          <Loader2 className="w-4 h-4 animate-spin" />
        ) : (
          <Trash2 className="w-4 h-4" />
        )}
      </button>

      {/* Caption */}
      {image.caption && (
        <div className="absolute bottom-0 left-0 right-0 bg-black/60 text-white text-sm p-2 truncate">
          {image.caption}
        </div>
      )}
    </div>
  )
}

interface PortfolioGalleryProps {
  vendorId: string
}

export function PortfolioGallery({ vendorId }: PortfolioGalleryProps) {
  const { data: images = [], isLoading } = usePortfolio(vendorId)
  const reorderMutation = useReorderPortfolio()
  const deleteMutation = useDeletePortfolioImage()
  const [deletingId, setDeletingId] = useState<string | null>(null)

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  )

  const handleDragEnd = async (event: DragEndEvent) => {
    const { active, over } = event

    if (over && active.id !== over.id) {
      const oldIndex = images.findIndex((img) => img.id === active.id)
      const newIndex = images.findIndex((img) => img.id === over.id)
      const reordered = arrayMove(images, oldIndex, newIndex)

      // Update order indices
      const updates = reordered.map((img, idx) => ({
        id: img.id,
        order_index: idx,
      }))

      try {
        await reorderMutation.mutateAsync({ vendorId, images: updates })
      } catch (error) {
        toast.error('Failed to reorder images')
      }
    }
  }

  const handleDelete = async (imageId: string) => {
    const image = images.find(img => img.id === imageId)
    if (!image) return

    setDeletingId(imageId)
    try {
      // Delete from storage first
      await deleteFromStorage(image.storage_path)
      // Then delete from database
      await deleteMutation.mutateAsync({ id: imageId, vendorId })
      toast.success('Image deleted')
    } catch (error) {
      toast.error('Failed to delete image')
    } finally {
      setDeletingId(null)
    }
  }

  if (isLoading) {
    return (
      <div className="flex justify-center py-8">
        <Loader2 className="w-8 h-8 animate-spin text-gray-400" />
      </div>
    )
  }

  if (images.length === 0) {
    return (
      <div className="text-center py-8 text-gray-500">
        No portfolio images yet. Upload some to showcase your work!
      </div>
    )
  }

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragEnd={handleDragEnd}
    >
      <SortableContext items={images.map(i => i.id)} strategy={rectSortingStrategy}>
        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
          {images.map((image) => (
            <SortableImage
              key={image.id}
              image={image}
              onDelete={handleDelete}
              isDeleting={deletingId === image.id}
            />
          ))}
        </div>
      </SortableContext>
    </DndContext>
  )
}
```
  </action>
  <verify>
- File exists at frontend/src/components/vendor/PortfolioGallery.tsx
- Uses useSortable from @dnd-kit/sortable
- SortableContext wraps the grid
- handleDragEnd calls useReorderPortfolio mutation
- Delete removes from both storage and database
  </verify>
  <done>
Sortable portfolio gallery with drag handles and delete functionality ready.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create availability calendar component</name>
  <files>frontend/src/components/vendor/AvailabilityCalendar.tsx</files>
  <action>
Create AvailabilityCalendar.tsx with multiple date selection:

```typescript
import { useState } from 'react'
import { DayPicker, DateRange } from 'react-day-picker'
import { format, isSameDay, isAfter, startOfToday } from 'date-fns'
import { toast } from 'sonner'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { useBlockedDates, useBlockDates, useUnblockDate } from '@/hooks/useAvailability'
import { Calendar, Loader2, X } from 'lucide-react'

interface AvailabilityCalendarProps {
  vendorId: string
}

export function AvailabilityCalendar({ vendorId }: AvailabilityCalendarProps) {
  const { blockedDates, availability, isLoading } = useBlockedDates(vendorId)
  const blockMutation = useBlockDates()
  const unblockMutation = useUnblockDate()

  const [selectedDates, setSelectedDates] = useState<Date[]>([])
  const [note, setNote] = useState('')
  const today = startOfToday()

  const isDateBlocked = (date: Date) =>
    blockedDates.some(blocked => isSameDay(blocked, date))

  const handleDayClick = (day: Date, modifiers: any) => {
    // Don't allow selecting past dates
    if (!isAfter(day, today) && !isSameDay(day, today)) return

    if (isDateBlocked(day)) {
      // Unblock this date
      handleUnblock(day)
    } else {
      // Toggle selection for new blocking
      setSelectedDates(prev => {
        const exists = prev.some(d => isSameDay(d, day))
        if (exists) {
          return prev.filter(d => !isSameDay(d, day))
        }
        return [...prev, day]
      })
    }
  }

  const handleUnblock = async (date: Date) => {
    try {
      await unblockMutation.mutateAsync({ vendorId, date })
      toast.success(`${format(date, 'MMM d')} is now available`)
    } catch (error) {
      toast.error('Failed to update availability')
    }
  }

  const handleBlockSelected = async () => {
    if (selectedDates.length === 0) return

    try {
      await blockMutation.mutateAsync({
        vendorId,
        dates: selectedDates,
        note: note || undefined,
      })
      toast.success(`${selectedDates.length} date(s) marked as booked`)
      setSelectedDates([])
      setNote('')
    } catch (error) {
      toast.error('Failed to update availability')
    }
  }

  const handleClearSelection = () => {
    setSelectedDates([])
    setNote('')
  }

  if (isLoading) {
    return (
      <div className="flex justify-center py-8">
        <Loader2 className="w-8 h-8 animate-spin text-gray-400" />
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="flex flex-col md:flex-row gap-6">
        {/* Calendar */}
        <div className="flex-1">
          <DayPicker
            mode="multiple"
            selected={selectedDates}
            onDayClick={handleDayClick}
            disabled={{ before: today }}
            modifiers={{
              booked: blockedDates,
              selected: selectedDates,
            }}
            modifiersClassNames={{
              booked: 'bg-red-100 text-red-800 font-medium',
              selected: 'bg-blue-100 text-blue-800 ring-2 ring-blue-500',
            }}
            className="border rounded-lg p-4"
            numberOfMonths={1}
          />
        </div>

        {/* Actions panel */}
        <div className="w-full md:w-64 space-y-4">
          <div>
            <h3 className="font-medium mb-2">Legend</h3>
            <div className="space-y-2 text-sm">
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 bg-red-100 rounded" />
                <span>Booked / Unavailable</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 bg-blue-100 rounded ring-2 ring-blue-500" />
                <span>Selected to block</span>
              </div>
            </div>
          </div>

          {selectedDates.length > 0 && (
            <div className="border rounded-lg p-4 space-y-4 bg-gray-50">
              <div>
                <p className="font-medium">
                  {selectedDates.length} date(s) selected
                </p>
                <p className="text-sm text-gray-500">
                  {selectedDates.map(d => format(d, 'MMM d')).join(', ')}
                </p>
              </div>

              <div className="space-y-2">
                <Label htmlFor="note">Private Note (optional)</Label>
                <Input
                  id="note"
                  value={note}
                  onChange={(e) => setNote(e.target.value)}
                  placeholder="e.g., Smith wedding"
                />
              </div>

              <div className="flex gap-2">
                <Button
                  onClick={handleBlockSelected}
                  disabled={blockMutation.isPending}
                  className="flex-1"
                >
                  {blockMutation.isPending ? (
                    <Loader2 className="w-4 h-4 animate-spin" />
                  ) : (
                    'Mark as Booked'
                  )}
                </Button>
                <Button
                  variant="outline"
                  onClick={handleClearSelection}
                  disabled={blockMutation.isPending}
                >
                  <X className="w-4 h-4" />
                </Button>
              </div>
            </div>
          )}

          <div className="text-sm text-gray-500">
            <p>Click a date to select it for blocking.</p>
            <p>Click a red date to make it available again.</p>
          </div>
        </div>
      </div>

      {/* Upcoming blocked dates list */}
      {availability && availability.length > 0 && (
        <div className="border-t pt-4">
          <h3 className="font-medium mb-3">Blocked Dates</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
            {availability.slice(0, 12).map((item) => (
              <div
                key={item.id}
                className="flex items-center justify-between p-2 bg-red-50 rounded text-sm"
              >
                <div>
                  <span className="font-medium">
                    {format(new Date(item.blocked_date), 'MMM d, yyyy')}
                  </span>
                  {item.note && (
                    <span className="text-gray-500 ml-2">- {item.note}</span>
                  )}
                </div>
                <span className="text-red-600 text-xs font-medium">Booked</span>
              </div>
            ))}
          </div>
          {availability.length > 12 && (
            <p className="text-sm text-gray-500 mt-2">
              +{availability.length - 12} more blocked dates
            </p>
          )}
        </div>
      )}
    </div>
  )
}
```
  </action>
  <verify>
- File exists at frontend/src/components/vendor/AvailabilityCalendar.tsx
- Uses DayPicker from react-day-picker with mode="multiple"
- useBlockedDates hook provides blocked dates as Date objects
- Blocked dates styled with red background and "Booked" indicator
- Private note field for vendor's reference
- Past dates disabled
  </verify>
  <done>
Availability calendar with multiple selection, blocking/unblocking, and private notes ready.
  </done>
</task>

</tasks>

<verification>
1. PortfolioUploader shows preview and validates file size/type
2. PortfolioGallery shows grid of images with drag handles
3. Dragging and dropping reorders images (check order_index in database)
4. AvailabilityCalendar shows red for blocked dates
5. Clicking unblocked date selects it (blue highlight)
6. Clicking "Mark as Booked" creates vendor_availability record
</verification>

<success_criteria>
- All three components compile without TypeScript errors
- dnd-kit imports work (package installed in 02-03)
- Storage functions work (from 02-03)
- Hooks provide data correctly (from 02-02)
</success_criteria>

<output>
After completion, create `.planning/phases/02-vendor-supply-platform/02-05-SUMMARY.md`
</output>
